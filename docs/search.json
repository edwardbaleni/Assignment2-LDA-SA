[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "This is a website for the submission of Assignment 2 for STA5073Z.\nGroup: Edward Baleni, Luke Barnes and Andrea Plumbley\nPLAGIARISM DECLARATION\n\nI know that plagiarism is wrong. Plagiarism is to use another’s work and pretend that it is one’s own.\nI have used a generally accepted citation and referencing style. Each contribution to, and quotation in, this tutorial/report/project from the work(s) of other people has been attributed, and has been cited and referenced.\nThis tutorial/report/project is my own work.\nI have not allowed, and will not allow, anyone to copy my work with the intention of passing it off as his or her own work.\nI acknowledge that copying someone else’s assignment or essay, or part of it, is wrong, and declare that this is my own work.\n\nNote that agreement to this statement does not exonerate you from the University’s plagiarism rules (http://www.uct.ac.za/uct/policies/plagiarism_students.pdf).\nSignature: A. Plumbley, E. Baleni, L. Barnes\nDate: 17/10/2023"
  },
  {
    "objectID": "Template.html",
    "href": "Template.html",
    "title": "Assignment 2: Report",
    "section": "",
    "text": "Due to the large volume of text data available today, sentiment analysis and topic modelling have become popular methods to classify documents (or other pieces of text) based on their emotional content and topics or themes present. Sentiment analysis and topic modelling methods provide techniques to programmatically categorize documents and does not require individuals to sit and read through large documents. In this report, sentiment analysis and topic modelling is applied to State of the Nation Addresses in South Africa between 1994 and 2023. The sentiment analysis section allows one to identify different presidents sentiment conveyed in their speeches and how this changed over time. Topic modelling highlights what the major themes are that each president speaks about and if the proportion of time spent on each topic changes over time. The results of the sentiment analysis showed that on the whole South African presidents have a net positive sentiment in their speeches. Specifically Mandela and Mbeki became more positive in their speeches over the time of their presidency while Zuma and Ramaphosa become less positive during their time in office. These findings correlate with what was happening in South Africa at the times of their respective presidencies.\n\nADD TOPIC MODELLING RESULTS ONCE COMPLETE"
  },
  {
    "objectID": "Template.html#introduction",
    "href": "Template.html#introduction",
    "title": "Assignment 2: Report",
    "section": "Introduction",
    "text": "Introduction\nThe aim of this assignment is to provide a descriptive analysis of the State of the Nation speeches in South Africa between 1994 and 2022. This descriptive analysis is performed using sentiment analysis and topic modelling. Sentiment analysis aims to describe the content of text in terms of its ‘emotions’ (Silge & Robinson, 2017). The purpose of performing sentiment analysis on these speeches is to identify the overall tone or emotion of the speech and identify how this might change over time or as presidents change. Topic modelling is a technique that aims to summarize text, in this case speeches, in terms of a number of topics. It is a way of categorizing speeches into different topics and identifying the main themes of a body of text (Silge & Robinson, 2017. This is of interest in order to identify what topics or themes are important in the context of the government of South Africa and how these themes or main topics may change over time or over different presidents.\nBefore the analysis is applied to the data a brief literature review will be given. Following this the data and any cleaning that was done will be discussed. The methods for performing sentiment analysis and topic modelling will be outlined. Finally the results of the analysis on the SONA speeches data will be presented and discussed.\nChat GPT was used as an aid to this assignment. The purpose of this was to experiment large language models and to assess Chat GPT’s ability to assist with the assignment. A brief summary of how well it did and how it responded to different prompts and guides in given in Use of ChatGPT appendix (which can be found on Use of ChatGPT tab of this website)."
  },
  {
    "objectID": "Template.html#literature-review",
    "href": "Template.html#literature-review",
    "title": "Assignment 2: Report",
    "section": "Literature Review",
    "text": "Literature Review\n\nSentiment Analysis\nSentiment analysis is a technique to programmatically asses the emotional content of a text (Silge & Robinson, 2017). It gives a way, through the use of sentiment lexicons to understand the attitudes and opinions expressed in a piece of text or speech and identify if they are positive or negstive (Silge & Robinson, 2017). Sentiment analysis can also be seen as a classification method as it classifies documents into positive or negative categories or more sophiscated classes such as joy, disgust or anger, depending on which specific sentiment lexicon one is using in the analysis (Medhat et al., 2014). Due to the large amount of text data around today, sentiment analysis is becoming more popular and necessary in order to classify documents and arrange them in terms of sentiment because the volume is too large for documents to be manually sifted through by people to decide on its emotional contents (Medhat et al., 2014). There are a number of application areas for sentiment analysis including customer feedback and reviews, social media monitoring, market research and political analysis. In the context of the SONA data the sentiment analysis can be seen as a form of political analysis and also a way in which to describe how the country is doing in terms of governance and economy of the years from 1994 to 2023.\n\n\nTopic Modelling\nTopic Modelling is a unsupervised classification technique for grouping documents according to topic or theme (Silge & Robinson, 2017). The particular topic modelling method that is popular is Latent Dirichlet Allocation (Silge & Robinson, 2017). The key ideas of this method is to consider documents as a collection of topics and topics as a collection of words (Silge & Robinson, 2017). Topic modelling thus allows one to categorize documents into broad themes and calculate the proportions of each topic or theme that appear in a document. Topic modelling has been done on SONA speeches before by Miranda and Bringula (2021) who analysed the State of the Nation Addresses in the Phillipines. Through the use of Latent Dirichlet Allocation, they were able to identify three major topics each linked with concerns within the country (Miranda & Bringula, 2021). In general one is able to pull out and label a topic by looking at the sentences that contain the words in that topic. This however needs to be discussed and consensus reached on what labels best represents the topic (Miranda & Bringula, 2021). This gives an indication that selecting the labels for topics is not always easy and may in some instances not represent perfectly the true underlying topic picked up by the LDA analysis."
  },
  {
    "objectID": "Template.html#data",
    "href": "Template.html#data",
    "title": "Assignment 2: Report",
    "section": "Data",
    "text": "Data\nAs mentioned, the data for this analysis is a collection of 36 speeches delivered as State of the Nation Addresses between 1994 and 2022. These speeches were delivered by 6 different presidents: de Klerk, Mandela, Mbeki, Motlanthe, Zuma and Ramaphosa.\nThis data needed to be cleaned before sentiment analysis or topic modelling could be done. The data was cleaned by removing punctuation marks and numbers from the speeches. Stop words, which are common words such as ‘the’, ‘and’ and ‘they’ were also removed from the speeches.\nIn order to perform sentiment analysis the speeches needed to be tokenized into shorter parts such as bigrams and words in order to assess the sentiment of each smaller part and then aggregate these sentiments to understand the sentiment of the speech as a whole. The speeches are tokenized first into sentences and then into words using the unnest_tokens() function in R.\nA separate analysis is done on bigrams in order to consider negation of words, for example ‘improvement’ vs ‘no improvement’, and to assess how frequently negation occurred. In order to perform this analysis the unnest_tokens() function was also done specifying the token argument to ‘ngrams’ and setting ‘n’ to 2. The same cleaning was done in order to remove numbers and punctuation marks before the speeches were tokenized in this way. In terms of stop word removal, stop words were removed except for those stop words that are negation words. The qdapDictionary::negation.words dictionary was used to identify negation words and remove them from the stop words before removing stop words from the analysis.\nFor topic modelling, for which Latent Dirichlet allocation will be applied, the data format that will be used is a DocumentTermMatrix object. Once the speeches have been tokenized and cleaned, as was done above, a DTM object is created using the cast_dtm() function which is part of the tidytext package in R. The cast_dtm() function is applied to the data frame containing the words, speechIDs and counts and turns the data frame into a DTM object using these variables."
  },
  {
    "objectID": "Template.html#methods",
    "href": "Template.html#methods",
    "title": "Assignment 2: Report",
    "section": "Methods",
    "text": "Methods\n\nSentiment Analysis\nIn order to perform sentiment analysis, sentiment lexicons are used. These lexicons contain many words which are labelled according to their sentiment. The main lexicon that was made use of here for analysis was the bing dictionary which labels words as positive or negative. The affin dictionary gives each word a score between negative five and five, from negative to positive sentiments.\nIn order to get each words sentiment, the data frame containing individual words, with an associated president, year ans sentence ID is left joined with the bing lexicon in order to get their associated positive or negative sentiment. Because many of the words in the speeches are not in the dictionary, these words are assigned with a sentiment value of neutral instead of removing them from analysis. This is not an ideal situation as it may mean that words which are very emotively loaded are being assigned as neutral and so one could miss the true sentiment of a sentence or speech however it is better than removing all these words from the analysis completely.\nIn order to analyze the sentiment of different presidents we can consider each presidents most commonly used positive and negative words which can be found using filtering by president and filtering by positive or negative sentiment.\nIn addition one can consider how sentiment changes over time and by president by considering the number of positive and negative sentiment associated words and seeing how this changes over time. This can also be done using the filter() function and filtering by year. In this way one can see if the percentage of positive sentiment in a speech increased or decreased as well as identify the net sentiment of the SONA speeches over time.\nSentiment analysis, with unigram tokens, can effectively capture the sentiment associated with a word. However, there are instances where negation words precede these sentiments. Negation words are words that reverse the sentiment of a succeeding word in sentiment analysis, essentially reversing its polarity (). In unigram-based sentiment analysis, it becomes necessary to account for this reversal in sentiment when negation words are present. Bigrams, which are pairs of consecutive words, prove to be valuable in investigating this phenomenon. Analyzing negation in conjunction with unigram sentiment helps assess whether some positive or negative sentiments might be incorrectly classified and whether the most frequently used positive/negative words truly represent a polar sentiment to the realization discussed.\nThe negation words used here have been drawn from the dictionary provided by (). It’s important to note that this list of negation words is not exhaustive, and this limitation could affect the outcomes of the analysis.\nFor this to happen, tokenization by bigrams occured. These words were subsequently separated so that stop words could be filtered out of them. The stop word dictionary provided by\n\n\nTopic Modelling\nThe second technique used to analyze the State of the Nation Addresses is topic modelling for which Latent Dirichlet allocation is used. The basic components of Latent Dirichlet Allocation (LDA) are as follows:\n\nEach document (in this case speech) is made up of a mixture of topics.\nEach topic is made up of a mixture of words.\n\nIf one wanted to generate a speech, first the number of words to generate must be specified. Following that one makes a draw from a Dirichlet distribution which gives a vector of proportions of each topic in the document. Then one divides up the number of words between the topics in the proportions specified. The words are then drawn from a conditional distribution which gives the probability of word i appearing given that the topic is topic j. LDA is therefore a hierarchical model, sampling first the topic proportions and then sampling the words given the topic proportions.\nThe topicmodels package is used in R in order to perform LDA on the SONA data using the LDA() function. A seed of 2023 is set within the LDA control argument in order to ensure results are reproducible. The LDA() function takes in as arguments the DocumentTermMatrix of the speeches, as discussed in the data section and a parameter k which specifies the number of topics one wants to obtain.\nIn terms of selecting the number of topics to look for, this has to be specified in the LDA() function when it is run. Miranda and Bringula (2021) selected three topics in analyzing the Philippines SONA speeches. For this analysis: two, three and four topics were considered. A few of the different results for these different numbers of topics will be presented in the results. It was found that four topics was best and were easiest to categorize into understandable labels. For this reason the majority of topic modelling results presented below are based on the four topic case."
  },
  {
    "objectID": "Template.html#results-and-discussion",
    "href": "Template.html#results-and-discussion",
    "title": "Assignment 2: Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nHaving outlined the methods used to perform sentiment analysis and topic modelling, the results and analysis of the speeches is now given.\n\nSentiment Analysis\n\nIndividual Words\nFigure 1 below shows the most common positive words used by each president. A number of words stand out here. “Regard” is used very frequently by Mandela, Mbeki and Motlanthe while Zuma and Ramaphosa both say “support” often. Mandela and de Klerk’s most common words are similar in terms of theme, examples being “freedom”, “peaceful” and “reconciliation”. These types of positive words are expected from these two presidents who were in office at the end of apartheid in South Africa.\nIt can also be noted that Ramaphosa and Zuma share similar positive words including “reform”, “improve”, “sustainable” and “progress” which indicates where much of their positive focus lies introducing new reforms or advocating for economic improvements and sustainable economic policy.\n\n\n\n\n\nFigure 1: The most commonly used positive words used by each president.\nFigure 2 below shows the most frequently used negative word by each president. Again here, as with the positive sentiment words, a couple words stand out which can highlight what the major issues at the time of each presidency. For Mbeki and Motlanthe, the most common negative sentiment word is poverty which indicates that that was a large problem at the time of their presidency or a negative aspect of the country that was focused on significantly in their speeches. Ramaphosa and Zuma use “corruption” many times in their speeches and this again points to what was regarded by them as a major negative issue to be addresses. In addition to corruption they both also speak of crime and poverty fairly frequently.\n\n\n\n\n\nFigure 2: The most commonly used negative words used by each president.\nHaving considered overall the most commonly used positive and negative words by each president which gives an idea of what the positive and negative issues of the country were at the time, sentiment changes over time are now considered. Figure A and B in Appendix 1 give the changes in positive and negative sentiment associated words over time. Figure 3 below gives the net change in sentiment overtime, where each president is represented by a different symbol shown in the legend. This net sentiment shows the net positive sentiments over negative sentiments. It is clear that overall most presidents have net positive speeches, using more positive than negative words. An exception to this is de Klerk where the value is just less than zero indicating more negative words than positive ones were said and Mandela’s 1998 speech had an almost equal amount of negative and positive words. It must again be noted that those words not present in the bing dictionary were set as neutral and so there may be words that would slightly change these net sentiment values.\nMbeki and Ramaphosa stand out as having the highest net positive sentiment. Between 2003 and 2005 the SONA speeches were significantly more positive than negative - WHY??\nRamaphosa 2019 State of the Nation address also has a high net positive value. This was the year that Ramaphosa was elected as president and before the start of the COVID-19 pandemic and so it makes intuitive sense that this specific speech of Ramaphosa’s was the largest in net positive sentiment as it was likely a hopeful speech talking about change that would come after Zuma’s presidency and attempted impeachment.\nThe speeches from 2020 to 2023 decreased significantly in net positive sentiment which makes sense due to the COVID-19 pandemic and its economic impact on the country. However overall these SONA speeches were still overall positive than negative but not as positive as Ramaphosa first official SONA as president (2019).\n\n\n\n\n\nFigure 3: Net positive sentiment in speeches over the years.\nFIgure 4 below gives the change in net positive sentiment over each of the presidents terms in office. For de Klerk and Motlanthe this is not applicable because they each only delivered one address. Mandela and Mbeki became increasing positive in their speeches over their presidencies which Zuma and Ramaphosa delivered speeches that were less and less positive. It is expected that Mandela and Mbeki would have become increasingly more positive as their presidencies covered a time in which democracy was new in South Africa and significant changes made in government from the apartheid era which increased positive sentiment in the country. In the case of Zuma a decrease in positive sentiment makes sense as particularly toward the end of his presidency he was facing numerous allegations of corruption which likely would have impacted his speech sentiment. As already mentioned the second year of Ramaphosa’s presidency saw the start of the pandemic which would have decreased the amount of positive sentiment in his speeches.\n\n\n\n\n\nFigure 4: Change in Net Positive Sentiment between first and last speech, for each president.\n\n\n\n\n\nBigrams\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic Modelling\n\n\n\n\n\n\n\n\nFigure 5: Top 10 Terms in each Topic by word-topic probability."
  },
  {
    "objectID": "Template.html#conclusion",
    "href": "Template.html#conclusion",
    "title": "Assignment 2: Report",
    "section": "Conclusion",
    "text": "Conclusion\nThis report has outlined a descriptive analysis of the State of the Nation speeches in South Africa between 1994 and 2023. This descriptive analysis was carried out by implementing sentiment analysis and topic modelling on the speech data. This analysis has highlighted the importance of being able to manipulate and wrangle text data in order to convert it into useful formats. In addition it has shown how both sentiment analysis and topic modelling are useful tools to extract meaning from text data without having to read through the full speeches. The sentiment analysis showed the positive or negative sentiments of each president and described how these sentiments changed over time. Significant increases or decreases in positive sentiment were also able to be noted. The topic modelling technique pulled out four topics that the presidents conveyed in their speeches. These topics were able to be tracked over time for each president which gave insight into which topics different presidents thought were more or less important to speak about. There are some limitations to the analysis that has been done such as the lack of certain words in the sentiment lexicons and assumptions of ‘neutral’ words. In addition, for the topic modelling, there is no set number of topics that should be chosen and so a potential limitation is not conducting more analysis with varying numbers of topics. Overall this report has given an overview of how to conduct a descriptive analysis of text data and has highlighted two popular techniques, sentiment analysis and topic modelling."
  },
  {
    "objectID": "Template.html#references",
    "href": "Template.html#references",
    "title": "Assignment 2: Report",
    "section": "References",
    "text": "References\nBringula, R., Ulfa, S., Miranda, J and Atienze, F. 2022. Text mining analysis on students’ expectations and anxieties towards data analytics course. Cogent Engineering.\nMiranda, J. and Bringula, R. 2021. Exploring Phillipine presidents’ speeches: a sentiment analysis and topic modeling approach. Cogent Social Sciences.\nMedhat, W., Hassan, A. and Korashy, H. 2014. Sentiment analysis algorithms and applications: a survey. Ain Shams Engineering Journal, 5(4).\nR Core Team. 2022. R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.\nSilge, J. and Robinson, D. 2016. Text Mining with R, A tidy approach. O’Reilly.\nSilge, J. and Robinson, D. 2016. “tidytext: Text Mining and Analysis Using Tidy Data Principles in R.” JOSS, 1(3). doi:10.21105/joss.00037 https://doi.org/10.21105/joss.00037.\nWickham H., François R., Henry L., Müller K., Vaughan D. 2023. dplyr: A Grammar of Data Manipulation. R package version 1.1.3, https://CRAN.R-project.org/package=dplyr.\nWickham, H. 2022. stringr: Simple, Consistent Wrappers for Common String Operations. R package version 1.5.0, https://CRAN.R-project.org/package=stringr."
  },
  {
    "objectID": "Bigrams and Negation.html",
    "href": "Bigrams and Negation.html",
    "title": "Negation",
    "section": "",
    "text": "### Libraries\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the \u001b]8;;http://conflicted.r-lib.org/\u0007conflicted package\u001b]8;;\u0007 to force all conflicts to become errors\n\nlibrary(tidytext)\nlibrary(tokenizers)\nlibrary(gghighlight)\nlibrary(tictoc)\nlibrary(ggpubr)\n\n### Load Data\n\nload(\"SonaData.RData\")\nload(\"dsfi-lexicons.Rdata\")\n\n### Separate speeches into sentences and sentences into words\n\nunnest_reg = \"[^\\\\w_#@']\"\n\nspeechSentences = as_tibble(sona) %>%\n  rename(president = president_13) %>%\n  unnest_tokens(sentences, speech, token = \"sentences\") %>%\n  select(president, year, sentences) %>%\n  mutate(sentences, sentences = str_replace_all(sentences, \"’\", \"'\")) %>%\n  mutate(sentences, sentences = str_replace_all(sentences, \"'\", \"\")) %>%\n  mutate(sentences, sentences = str_remove_all(sentences, \"[0-9]\")) %>%\n  mutate(sentID = row_number())\n\nwordsWithSentID = speechSentences %>% \n  unnest_tokens(word, sentences, token = 'regex', pattern = unnest_reg) %>%\n  filter(str_detect(word, '[a-z]')) %>%\n  filter(!word %in% stop_words$word) %>%\n  select(sentID, president, year, word)\n\n### Join with Sentiment Lexicon\n\nwordsSentiment = wordsWithSentID %>% \n  left_join(bing, by = \"word\") %>%\n  rename(bing_sentiment = sentiment) %>%\n  mutate(bing_sentiment = ifelse(is.na(bing_sentiment), \"neutral\", bing_sentiment))\n\n#head(wordsSentiment)\n#table(wordsSentiment$bing_sentiment)"
  },
  {
    "objectID": "Bigrams and Negation.html#bigrams",
    "href": "Bigrams and Negation.html#bigrams",
    "title": "Negation",
    "section": "Bigrams",
    "text": "Bigrams\nSentiment analysis, with unigram tokens, can effectively capture the sentiment associated with a word. However, there are instances where negation words precede these sentiments. Negation words are words that reverse the sentiment of a succeeding word in sentiment analysis, essentially reversing its polarity (). In unigram-based sentiment analysis, it becomes necessary to account for this reversal in sentiment when negation words are present. Bigrams, which are pairs of consecutive words, prove to be valuable in investigating this phenomenon. Analyzing negation in conjunction with unigram sentiment helps assess whether some positive or negative sentiments might be incorrectly classified and whether the most frequently used positive/negative words truly represent a polar sentiment to the realization discussed.\nThe negation words used here have been drawn from the dictionary provided by (). It’s important to note that this list of negation words is not exhaustive, and this limitation could affect the outcomes of the analysis.\n\n# Tokenize into bigram\nbigram <- speechSentences %>% \n  unnest_tokens(word, sentences, token = 'ngrams', n = 2)\n\n# Collect some negation words from qdap dictionary\nnegation_words <-  qdapDictionaries::negation.words\nclean <- function(x){\n  hold <- str_replace_all(x, \"’\", \"'\")\n  hold <- str_replace_all(x, \"'\", \"\")  \n}\nnegation_words <- unlist(lapply(negation_words, clean))\n\n# Remove negation words from list of stop words\nstop_words <- stop_words %>%\n  filter(!word %in% negation_words)\n\n\nbigrams_separated <- bigram %>%\n  separate(word, c(\"word1\", \"word2\"), sep = \" \")\n\n# Filter out stop words\nbigrams_filtered <- bigrams_separated %>%\n  filter(!word1 %in% stop_words$word) %>%\n  filter(!word2 %in% stop_words$word)\n\n# Unite bigram\nbigrams_unite <- bigrams_filtered %>%\n  unite(word1, word2)\n\n# Obtain the negated words\nnegated_words <- bigrams_filtered %>%\n  filter(word1 %in% negation_words) %>%\n  inner_join(afinn, by = c(word2 = \"word\")) %>%\n  count(word1, word2, value, sort = TRUE) %>%\n  arrange(desc(n))\n\n# Plot of the negated words\nnegated_words %>%\n  mutate(Contribution = n * value) %>%\n  arrange(desc(abs(Contribution))) %>%\n  mutate(word2 = reorder(word2, Contribution)) %>%\n  filter(abs(value) > 1.9) %>%\n  ungroup() %>%\n  ggplot(aes(Contribution, word2, fill = word1)) +\n  geom_col(show.legend = FALSE) +\n  facet_wrap(~word1, ncol = 2, scales = \"free_y\") +\n  theme_bw() +\n  ylab(\"Negated Word\")\n\n\n\n# Sentiment of a bigram\n# reverse the sentiment of word2 whenever it is preceded by a negation word, and then add up the number of positive and negative words within a bigram and take the difference.\nbigrams_filtered <- bigrams_filtered %>% \n  # add sentiment for word 1\n  left_join(bing, by = c(word1 = 'word')) %>%\n  rename(sentiment1 = sentiment) %>%\n  mutate(sentiment1 = ifelse(is.na(sentiment1), 'neutral', sentiment1)) %>%\n  # add sentiment for word 2\n  left_join(bing, by = c(word2 = 'word')) %>%\n  rename(sentiment2 = sentiment) %>%\n  mutate(sentiment2 = ifelse(is.na(sentiment2), 'neutral', sentiment2)) %>%\n  select(word1, word2, sentiment1, sentiment2, everything())\n\n# Reverse sentiment of negated words\nbigrams_filtered <- bigrams_filtered %>%\n  mutate(opp_sentiment2 = recode(sentiment2, \n                                 'positive' = 'negative',\n                                 'negative' = 'positive',\n                                 'neutral' = 'neutral')) %>%\n  mutate(sentiment2 = ifelse(word1 %in% negation_words, opp_sentiment2, sentiment2)) %>%\n  select(-opp_sentiment2)\n\n# Obtaining the net sentiment of the bigrams\nbigrams_filtered <- bigrams_filtered %>%\n  mutate(net_sentiment = (sentiment1 == 'positive') + (sentiment2 == 'positive') - \n           (sentiment1 == 'negative') - (sentiment2 == 'negative')) %>%\n  unite(bigram, word1, word2, sep = ' ', remove = FALSE)\n\n# Positive bigrams\nbigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col() + coord_flip() + xlab('Frequency') + theme_bw()\n\n\n\n# Negative biagrams\nbigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col() + coord_flip() + xlab('Frequency') +theme_bw()\n\n\n\n# Negated bigrams\nbigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n  filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col() + coord_flip() + xlab('Frequency') +theme_bw()\n\n\n\n\n\ns1 <- bigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n    filter(president == \"deKlerk\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n  arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) +   geom_col(fill = \"purple\", col = \"black\") + coord_flip() + ylab('Frequency')+ xlab(\"\") + theme_bw() + ggtitle(\"deKlerk\")\n\n# Negative biagrams\ns2 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n    filter(president == \"deKlerk\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"orange\", col = \"black\") + coord_flip() + ylab('Frequency')+xlab(\"\") + theme_bw(base_size = 12) + ggtitle(\"deKlerk\")\n\n# Negated bigrams\n# s3 <- bigrams_filtered %>%\n#   filter(net_sentiment < 0) %>% # get negative bigrams\n#     filter(president == \"deKlerk\") %>%\n#   filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n#   count(bigram, sort = TRUE) %>%\n#   filter(rank(desc(n)) < 20) %>%\n#     arrange(desc(n)) %>%\n#   mutate(id = 1:dim(.)[1]) %>%\n#   filter(id <= 15) %>%\n#   ggplot(aes(reorder(bigram,n),n)) + geom_col() + coord_flip() + xlab('Frequency') +theme_bw()\n\n\ns4 <- bigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n    filter(president == \"Zuma\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"purple\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Zuma\")\n\n# Negative biagrams\ns5 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n  filter(president == \"Zuma\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"orange\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Zuma\")\n\n# Negated bigrams\ns6 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n  filter(president == \"Zuma\") %>%\n  filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"red\", col = \"black\")+ coord_flip() + ylab('Frequency')+ \n  xlab(\"\") +theme_bw() + ggtitle(\"Zuma\")\n\ns7 <- bigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n  filter(president == \"Ramaphosa\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"purple\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Ramaphosa\")\n\n# Negative biagrams\ns8 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n    filter(president == \"Ramaphosa\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"orange\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 12) + ggtitle(\"Ramaphosa\")\n\n# Negated bigrams\ns9 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n    filter(president == \"Ramaphosa\") %>%\n  filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"red\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Ramaphosa\")\n\ns10 <-  bigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n    filter(president == \"Motlanthe\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) +  geom_col(fill = \"purple\", col = \"black\") + coord_flip() +ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 6) + ggtitle(\"Motlanthe\")\n\n# Negative biagrams\ns11 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n      filter(president == \"Motlanthe\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"orange\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Motlanthe\")\n\n# Negated bigrams\ns12 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n      filter(president == \"Motlanthe\") %>%\n  filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"red\", col = \"black\")+ coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Motlanthe\")\n\ns13 <-  bigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n      filter(president == \"Mbeki\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"purple\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 9) + ggtitle(\"Mbeki\")\n\n# Negative biagrams\ns14 <-  bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n  filter(president == \"Mbeki\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"orange\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 9) + ggtitle(\"Mbeki\")\n\n# Negated bigrams\ns15 <-  bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n  filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n  filter(president == \"Mbeki\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"red\", col = \"black\") + coord_flip() + ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 9) + ggtitle(\"Mbeki\")\n\ns16 <- bigrams_filtered %>%\n  filter(net_sentiment > 0) %>% # get positive bigrams\n  filter(president == \"Mandela\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n))  + geom_col(fill = \"purple\", col = \"black\") + coord_flip() + \n  ylab('Frequency')+ \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 7) + ggtitle(\"Mandela\")\n\n# Negative biagrams\ns17 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n    filter(president == \"Mandela\") %>%\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + geom_col(fill = \"orange\", col = \"black\") + coord_flip() + \n  ylab('Frequency') + \n  xlab(\"\") + theme_bw(base_size = 12) +\n  gghighlight(id <= 6) + ggtitle(\"Mandela\")\n\n# Negated bigrams\ns18 <- bigrams_filtered %>%\n  filter(net_sentiment < 0) %>% # get negative bigrams\n    filter(president == \"Mandela\") %>%\n  filter(word1 %in% negation_words) %>% # get bigrams where first word is negation\n  count(bigram, sort = TRUE) %>%\n  filter(rank(desc(n)) < 20) %>%\n    arrange(desc(n)) %>%\n  mutate(id = 1:dim(.)[1]) %>%\n  filter(id <= 15) %>%\n  ggplot(aes(reorder(bigram,n),n)) + \n  geom_col(fill = \"red\", col = \"black\") + \n  coord_flip() + \n  ylab('Frequency') + \n  xlab(\"\")\n  theme_bw(base_size = 12) + \n  ggtitle(\"Mandela\")\n\nList of 97\n $ line                      :List of 6\n  ..$ colour       : chr \"black\"\n  ..$ linewidth    : num 0.545\n  ..$ linetype     : num 1\n  ..$ lineend      : chr \"butt\"\n  ..$ arrow        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_line\" \"element\"\n $ rect                      :List of 5\n  ..$ fill         : chr \"white\"\n  ..$ colour       : chr \"black\"\n  ..$ linewidth    : num 0.545\n  ..$ linetype     : num 1\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ text                      :List of 11\n  ..$ family       : chr \"\"\n  ..$ face         : chr \"plain\"\n  ..$ colour       : chr \"black\"\n  ..$ size         : num 12\n  ..$ hjust        : num 0.5\n  ..$ vjust        : num 0.5\n  ..$ angle        : num 0\n  ..$ lineheight   : num 0.9\n  ..$ margin       : 'margin' num [1:4] 0points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ title                     : chr \"Mandela\"\n $ aspect.ratio              : NULL\n $ axis.title                : NULL\n $ axis.title.x              :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : num 1\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 3points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.title.x.top          :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : num 0\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 0points 3points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.title.x.bottom       : NULL\n $ axis.title.y              :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : num 1\n  ..$ angle        : num 90\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 3points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.title.y.left         : NULL\n $ axis.title.y.right        :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : num 0\n  ..$ angle        : num -90\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 0points 0points 3points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.text                 :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : chr \"grey30\"\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.text.x               :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : num 1\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 2.4points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.text.x.top           :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : num 0\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 0points 2.4points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.text.x.bottom        : NULL\n $ axis.text.y               :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 1\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 2.4points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.text.y.left          : NULL\n $ axis.text.y.right         :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 0\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 0points 0points 2.4points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ axis.ticks                :List of 6\n  ..$ colour       : chr \"grey20\"\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ lineend      : NULL\n  ..$ arrow        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_line\" \"element\"\n $ axis.ticks.x              : NULL\n $ axis.ticks.x.top          : NULL\n $ axis.ticks.x.bottom       : NULL\n $ axis.ticks.y              : NULL\n $ axis.ticks.y.left         : NULL\n $ axis.ticks.y.right        : NULL\n $ axis.ticks.length         : 'simpleUnit' num 3points\n  ..- attr(*, \"unit\")= int 8\n $ axis.ticks.length.x       : NULL\n $ axis.ticks.length.x.top   : NULL\n $ axis.ticks.length.x.bottom: NULL\n $ axis.ticks.length.y       : NULL\n $ axis.ticks.length.y.left  : NULL\n $ axis.ticks.length.y.right : NULL\n $ axis.line                 : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.line.x               : NULL\n $ axis.line.x.top           : NULL\n $ axis.line.x.bottom        : NULL\n $ axis.line.y               : NULL\n $ axis.line.y.left          : NULL\n $ axis.line.y.right         : NULL\n $ legend.background         :List of 5\n  ..$ fill         : NULL\n  ..$ colour       : logi NA\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ legend.margin             : 'margin' num [1:4] 6points 6points 6points 6points\n  ..- attr(*, \"unit\")= int 8\n $ legend.spacing            : 'simpleUnit' num 12points\n  ..- attr(*, \"unit\")= int 8\n $ legend.spacing.x          : NULL\n $ legend.spacing.y          : NULL\n $ legend.key                :List of 5\n  ..$ fill         : chr \"white\"\n  ..$ colour       : logi NA\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ legend.key.size           : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height         : NULL\n $ legend.key.width          : NULL\n $ legend.text               :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.text.align         : NULL\n $ legend.title              :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 0\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.title.align        : NULL\n $ legend.position           : chr \"right\"\n $ legend.direction          : NULL\n $ legend.justification      : chr \"center\"\n $ legend.box                : NULL\n $ legend.box.just           : NULL\n $ legend.box.margin         : 'margin' num [1:4] 0cm 0cm 0cm 0cm\n  ..- attr(*, \"unit\")= int 1\n $ legend.box.background     : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ legend.box.spacing        : 'simpleUnit' num 12points\n  ..- attr(*, \"unit\")= int 8\n $ panel.background          :List of 5\n  ..$ fill         : chr \"white\"\n  ..$ colour       : logi NA\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ panel.border              :List of 5\n  ..$ fill         : logi NA\n  ..$ colour       : chr \"grey20\"\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ panel.spacing             : 'simpleUnit' num 6points\n  ..- attr(*, \"unit\")= int 8\n $ panel.spacing.x           : NULL\n $ panel.spacing.y           : NULL\n $ panel.grid                :List of 6\n  ..$ colour       : chr \"grey92\"\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ lineend      : NULL\n  ..$ arrow        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_line\" \"element\"\n $ panel.grid.major          : NULL\n $ panel.grid.minor          :List of 6\n  ..$ colour       : NULL\n  ..$ linewidth    : 'rel' num 0.5\n  ..$ linetype     : NULL\n  ..$ lineend      : NULL\n  ..$ arrow        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_line\" \"element\"\n $ panel.grid.major.x        : NULL\n $ panel.grid.major.y        : NULL\n $ panel.grid.minor.x        : NULL\n $ panel.grid.minor.y        : NULL\n $ panel.ontop               : logi FALSE\n $ plot.background           :List of 5\n  ..$ fill         : NULL\n  ..$ colour       : chr \"white\"\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ plot.title                :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 1.2\n  ..$ hjust        : num 0\n  ..$ vjust        : num 1\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 0points 6points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ plot.title.position       : chr \"panel\"\n $ plot.subtitle             :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 0\n  ..$ vjust        : num 1\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 0points 0points 6points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ plot.caption              :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : num 1\n  ..$ vjust        : num 1\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 6points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ plot.caption.position     : chr \"panel\"\n $ plot.tag                  :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 1.2\n  ..$ hjust        : num 0.5\n  ..$ vjust        : num 0.5\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ plot.tag.position         : chr \"topleft\"\n $ plot.margin               : 'margin' num [1:4] 6points 6points 6points 6points\n  ..- attr(*, \"unit\")= int 8\n $ strip.background          :List of 5\n  ..$ fill         : chr \"grey85\"\n  ..$ colour       : chr \"grey20\"\n  ..$ linewidth    : NULL\n  ..$ linetype     : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_rect\" \"element\"\n $ strip.background.x        : NULL\n $ strip.background.y        : NULL\n $ strip.clip                : chr \"inherit\"\n $ strip.placement           : chr \"inside\"\n $ strip.text                :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : chr \"grey10\"\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : 'margin' num [1:4] 4.8points 4.8points 4.8points 4.8points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ strip.text.x              : NULL\n $ strip.text.x.bottom       : NULL\n $ strip.text.x.top          : NULL\n $ strip.text.y              :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : num -90\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ strip.text.y.left         :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : num 90\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ strip.text.y.right        : NULL\n $ strip.switch.pad.grid     : 'simpleUnit' num 3points\n  ..- attr(*, \"unit\")= int 8\n $ strip.switch.pad.wrap     : 'simpleUnit' num 3points\n  ..- attr(*, \"unit\")= int 8\n - attr(*, \"class\")= chr [1:2] \"theme\" \"gg\"\n - attr(*, \"complete\")= logi TRUE\n - attr(*, \"validate\")= logi TRUE\n\nggarrange( s1, s4, s7, s10, s13, s16, ncol=3, nrow=2)\n\n\n\nggarrange( s2, s5, s8, s11, s14, s17, ncol=3, nrow=2)\n\n\n\n# s3 has no observations\nggarrange( s6, s9, s12, s15, s18, ncol=3, nrow=2)"
  },
  {
    "objectID": "Appendix.html",
    "href": "Appendix.html",
    "title": "Appendix",
    "section": "",
    "text": "── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the \u001b]8;;http://conflicted.r-lib.org/\u0007conflicted package\u001b]8;;\u0007 to force all conflicts to become errors\n\n\n\n### Count the positive and negative sentiments in each speech \n\nwordsSentiment %>%\n  group_by(year, president) %>%\n  filter(bing_sentiment == \"positive\") %>%\n  count(bing_sentiment) %>%\n  ggplot(aes(x = year, y = n, shape = president)) + \n  geom_point(col = \"purple\", size = 5, stroke = 2) +\n  xlab(\"Year\") + ylab(\"Number of Positive Sentiments in Speech\") +\n  theme_bw(base_size = 12) + \n  scale_x_discrete(name = \"Year\", \n                   breaks = c(\"1994\",\"1999\",\"2004\", \"2009\", \n                              \"2014\", \"2019\", \"2023\")) +\n  scale_shape_manual(values = c(5, 15, 1, 18, 0, 16))\n\n\n\n\nFigure A: Positive Sentiment Over Time\n\nwordsSentiment %>%\n  group_by(year, president) %>%\n  filter(bing_sentiment == \"negative\") %>%\n  count(bing_sentiment) %>%\n  ggplot(aes(x = year, y = n, shape = president)) + \n  geom_point(col = \"orange\", size = 5, stroke = 2) +\n  xlab(\"Year\") + ylab(\"Number of Negative Sentiments in Speech\") + \n  theme_bw(base_size = 12) + \n  scale_x_discrete(name = \"Year\", \n                   breaks = c(\"1994\",\"1999\",\"2004\", \"2009\", \n                              \"2014\", \"2019\", \"2023\")) +\n  scale_shape_manual(values = c(5, 15, 1, 18, 0, 16))\n\n\n\n\nFigure B: Negative Sentiment Over Time"
  },
  {
    "objectID": "Use of ChatGPT.html",
    "href": "Use of ChatGPT.html",
    "title": "Using Chat GPT",
    "section": "",
    "text": "ChatGPT is a large language model that was used to assist with this assignment. The purpose of using ChatGPT was to assess its ability to help with the assignment and identify areas where it is helpful and identify any short comings.\nA number of different types of requests were made and its performance on these different types of requests varied, which are detailed below.\nOpen ended questions/Asking for guidance:\nThe first types of questions asked to ChatGPT were questions that were quite broad questions, asking for guidance and direction. For example: “What is the best way to perform sentiment analysis of speeches in R?” or “What are the major application areas for sentiment analysis?”. For question like these ChatGPT was quite helpful and provided lists with useful information which was beneficial for giving some direction on what to do or write about in the report. This included giving steps one could follow in R with associated code as well as lists of application areas with brief descriptions of how sentiment analysis is applied.\nProviding literature:\nThe second task that ChatGPT was attempted to be used for was to provide papers and textbooks for a brief literature review. Questions asked were “Can you recommend papers or textbooks on sentiment analysis for the purpose of a literature review?” and “Please also provide some papers for a brief literature review for Topic Modelling? Particularly any papers that have done topic modelling for presidential speeches”. Some papers provided were helpful and contained the right type of information that was being looked for however some of the papers it suggested seemed to not exist or were written by different authors then those specified by ChatGPT. In addition, a number of Machine Learning papers linked to sentiment analysis were recommended which while potentially interesting one would not necessarily be looking for when looking for basic sentiment analysis information. This was however not specified in the prompt and one needs to maybe be more specific with what type of literature one is looking for.\nAssistance with code:\nA number of prompts were give to ChatGPT regarding code and how to fix errors in R or create certain plots. This is one area that ChatGPT performs well in and is able to take a request for how to do something and produce chunks of code that execute the task. One area that ChatGPT did not do particularly well in was identifying why a particular error was occurring in R. For example with the S4 objects that are created when one does LDA analysis. ChatGPT did not know that one cannot make use of the $ operator for these S4 objects. Even after giving it the R error which specifies that this is the case, it still did not produce the correct code. The prompt had to be modified to specify that this is the case and request the correct operator before ChatGPT was able to give the correct code.\nAssistance with write up:\nThe final task for which the ChatGPT tool was used was to see its ability in writing up some of the report. For this purpose the prompt given was the introduction and asked to edit it and make it ‘better’ for a scientific paper. This is one area where ChatGPT does not perform particularly well. While it is able to write and generate text that makes sense and is good in terms of structure, the language used is quite ‘flowery’ and it uses many unnecessary words. This makes it very obvious that it was written by a Large Language Model and it does not convey the same tone that an academic would write. The response of model in terms of these write up questions were not used in the report because the responses were not particularly good.\nOverall it was found that while ChatGPT is a useful tool and can provide one with ideas to get start as well as code for when one is not sure what to do, one needs to be wary of taking everything it says without checking it. In addition sometimes its ‘fixes’ do not work as they should and prompts given need to be quite specific or need to help push the Large Language Model in the right direction in terms of what to look for or do.\nA link to some of the questions used is given here:\nChatGPT Conversation"
  }
]